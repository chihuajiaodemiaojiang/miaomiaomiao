执行环境和变量对象和作用域的关系,"`标识符`: 变量名, 函数名, 对象的属性名, 形参
`作用域`: 标识符生效的范围
`栈`: 内存中开辟的一个空间, 用来存放执行环境. '先入后出'
`执行环境`: js代码的运行环境. 分为全局执行环境和函数执行环境. 所有的标识符会有对应的执行环境
`作用域链[重点]`: 规定了标识符的查找规则. 先在当前作用域中查找,找到就使用,并终止查询.没有找到就依次向上查找,直到找到,如果在全局作用域都没有找到,就报错. `使用`: ***从要使用标识符的地方出发,依次往上查找即可***

`js代码的执行过程[理解]`: 首先在栈中默认会有一个全局执行环境,保存了全局的标识符. 代码依次执行的过程中,会将函数执行环境依次放入栈中,这个过程就叫""入栈"". 代码执行结束,所有的函数执行环境会依次""出栈"", 对应的函数执行环境中的标识符会被销毁.`细节`:全局执行环境不会出栈. 对应的全局标识符也不会被销毁.除非手动销毁或者关闭浏览器","`标识符`: 变量名, 函数名, 对象的属性名, 形参
`作用域`: 标识符生效的范围
`栈`: 内存中开辟的一个空间, 用来存放执行环境. '先入后出'
`执行环境`: js代码的运行环境. 分为全局执行环境和函数执行环境. 所有的标识符会有对应的执行环境
`作用域链[重点]`: 规定了标识符的查找规则. 先在当前作用域中查找,找到就使用,并终止查询.没有找到就依次向上查找,直到找到,如果在全局作用域都没有找到,就报错. `使用`: ***从要使用标识符的地方出发,依次往上查找即可***

`js代码的执行过程[理解]`: 首先在栈中默认会有一个全局执行环境,保存了全局的标识符. 代码依次执行的过程中,会将函数执行环境依次放入栈中,这个过程就叫""入栈"". 代码执行结束,所有的函数执行环境会依次""出栈"", 对应的函数执行环境中的标识符会被销毁.`细节`:全局执行环境不会出栈. 对应的全局标识符也不会被销毁.除非手动销毁或者关闭浏览器"
函数声明,"函数声明式: 
function fn() {}
函数表达式:
let fn = function(){}","函数声明式: 
function fn() {}
函数表达式:
let fn = function(){}"
剩余参数,"
// 剩余参数: 接收剩下的所有实参
function fn(a, b, ...arg) {
    console.log(a, b)
    console.log([...arg]); // [234, 34, 3, 445, 567, 233]
}
fn(1, 23, 234, 34, 3, 445, 567, 233)","
// 剩余参数: 接收剩下的所有实参
function fn(a, b, ...arg) {
    console.log(a, b)
    console.log([...arg]); // [234, 34, 3, 445, 567, 233]
}
fn(1, 23, 234, 34, 3, 445, 567, 233)"
函数参数默认值,"
 代码兼容性更强, 更健壮
// es5
// function sayHi(hero, saying) {
//     hero = hero || '亚索';
//     saying = saying || '哈撒给'
//     return `${hero}: ${saying}`
// }

// // console.log(sayHi('亚索', '哈撒给'));
// console.log(sayHi());
// console.log(sayHi('盖伦'));
// console.log(sayHi('盖伦', '德玛西亚'));"," 代码兼容性更强, 更健壮
// es5
// function sayHi(hero, saying) {
//     hero = hero || '亚索';
//     saying = saying || '哈撒给'
//     return `${hero}: ${saying}`
// }

// // console.log(sayHi('亚索', '哈撒给'));
// console.log(sayHi());
// console.log(sayHi('盖伦'));
// console.log(sayHi('盖伦', '德玛西亚'));"
es6函数的返回值,"function sayHi(hero = '亚索', saying = '哈撒给') {
    return `${hero}: ${saying}`
}
console.log(sayHi());
console.log(sayHi('小妲己'));
console.log(sayHi('小妲己', '请尽情吩咐妲己吧, 主人'));
console.log(sayHi('铁男', '只需要点一次就好了, 蠢蛋'));","function sayHi(hero = '亚索', saying = '哈撒给') {
    return `${hero}: ${saying}`
}
console.log(sayHi());
console.log(sayHi('小妲己'));
console.log(sayHi('小妲己', '请尽情吩咐妲己吧, 主人'));
console.log(sayHi('铁男', '只需要点一次就好了, 蠢蛋'));"
函数的返回值,"
1. 函数默认都会有返回值--`undefined`
2. 可以通过`return`这个关键字来声明函数的返回值, return后面的内容就是函数的返回值
3. 函数调用者的结果就是return后面的内容
4. return会终止函数内部其下面的代码执行","
1. 函数默认都会有返回值--`undefined`
2. 可以通过`return`这个关键字来声明函数的返回值, return后面的内容就是函数的返回值
3. 函数调用者的结果就是return后面的内容
4. return会终止函数内部其下面的代码执行"
立即执行函数,"语法: (函数)() | (函数())
特点: 不需要调用, 声明好后立即执行
好处: 减少了全局标识符, 节省了内存空间","语法: (函数)() | (函数())
特点: 不需要调用, 声明好后立即执行
好处: 减少了全局标识符, 节省了内存空间"
闭包,"概念: 跨作用域访问了标识符, 这种现象就是闭包
语法[了解]: 在父函数内部声明子函数, 在子函数里面调用父函数的变量, 然后将子函数挂载到全局window对象上.
作用: 早期的模块化思想的实现方案.
特点: 1. 减少了全局标识符,避免了变量的全局污染. 2. 但是那个被用来接收子函数的全局变量,会一直存储在内存中, 得不到释放.","概念: 跨作用域访问了标识符, 这种现象就是闭包
语法[了解]: 在父函数内部声明子函数, 在子函数里面调用父函数的变量, 然后将子函数挂载到全局window对象上.
作用: 早期的模块化思想的实现方案.
特点: 1. 减少了全局标识符,避免了变量的全局污染. 2. 但是那个被用来接收子函数的全局变量,会一直存储在内存中, 得不到释放."
预解析,"代码执行分为2步: 预解析; 依次执行
预解析: 变量提升和函数提升
变量提升: 当浏览器看到var这个关键字的时候, 会将变量的声明(不包含赋值)提升到当前作用域的最前面;
函数提升: 当浏览器看到function这个关键字的时候, 会将整个函数提升到当前作用域的最前面;

细节: 1. let不支持变量提升; 2. 函数表达式遵循的是变量提升,所以需要先声明,再调用","代码执行分为2步: 预解析; 依次执行
预解析: 变量提升和函数提升
变量提升: 当浏览器看到var这个关键字的时候, 会将变量的声明(不包含赋值)提升到当前作用域的最前面;
函数提升: 当浏览器看到function这个关键字的时候, 会将整个函数提升到当前作用域的最前面;

细节: 1. let不支持变量提升; 2. 函数表达式遵循的是变量提升,所以需要先声明,再调用"
